---
title: '1.7. Модульная организация программы'
metaTitle: 'Syntax Highlighting is the meta title tag for this page'
metaDescription: 'This is the meta description for this page'
---

Самый верхний уровень организации программы касается только достаточно больших проектов. Это разделение программы на более-менее независимые части (модули), их независимое проектирование и трансляция.

Иерархия
Любая сложная система не обходится без иерархии, без нее большая система превращается в нечто аморфное, необозримое и слабо управляемое.

Логическая иерархия отражает логических единиц программы, таких как функции, классы, библиотеки. Физическая иерархия касается физических единиц, на которые разбивается текст программы: файл (модуль), проект. Естественно, что между ними существует взаимосвязь, но не жесткая, синтаксическая, а технологическая, соблюдаемая программистом. Иерархия программных единиц имеет три уровня:

· элементом самого нижнего уровня является функция (в объектно-ориентированном программировании – метод класса). Это автономная синтаксическая единица языка. В традиционной технологии структурного программирования (см. 3.5) под модульным программированием понимают именно это: представление программы в виде системы взаимодействующих функций;

· несколько функций, объединенных общем описанием обрабатываемых ими структур данных, составляют библиотеку функций (эквивалент в ООП - класс). Все это – элементы логической иерархии. В физическом представлении им соответствует модуль (в интегрированных, закрытых системах) или файл исходного текста. Особенность модульного программирования в том и состоит, что отдельные модули могут разрабатываться, транслироваться и частично отлаживаться отдельно друг от друга. Но для этого им могут потребоваться описания интерфейсов взаимодействия (в Си – заголовочные файлы);

· вся программа в целом образуют проект. В интегрированных системах проект и все его модули могут быть представлены одним файлом. В традиционных системах программирования (к ним относится и Си/Си++) проект состоит из файлов исходного текста – модулей (обычные текстовые файлы), файла проекта, содержащего список модулей, настройки транслятора и т.п., а также вспомогательных файлов. В этом случае под проект отводится отдельная папка.

Подробнее создание проектов на Си в классической среде программирования рассматривается в 5.4, в объектно-ориентированной – в 11.1. Что же касается небольших программ, то в большинстве систем программирования оставлена возможность их автономной трансляции и выполнения вне проекта.

Способы модульной организации программы и взаимодействия ее частей в значительной степени обусловлены особенностями трансляции программы, поэтому здесь необходимы минимальные знания о трансляции и связывании программы и ее элементов.

Сущность трансляции. Компиляция и интерпретация
Под трансляцией в самом широком смысле можно понимать процесс восприятия компьютером программы, написанной на некотором формальном языке. При всем своем различии языки программирования имеют много общего и, в принципе, эквиваленты с точки зрения потенциальной возможности написать одну и ту же программу на любом из них. На самом деле сложно подвести под одну схему имеющееся многообразие языков программирования,

Компиляция - преобразование объектов (данных и операций над ними) с входного языка в объекты на другом языке для всей программы в целом с последующим выполнением полученной программы в виде отдельного шага.

Интерпретация - анализ отдельного объекта на входном языке с одновременным выполнением (интерпретацией).

Следовательно, компиляция и интерпретация отличаются не характером и методами анализа и преобразования объектов программы, а совмещением фаз обработки этих объектов во времени. То есть при компиляции фазы преобразования и выполнения действий разнесены во времени, но зато каждая из них выполняется над всеми объектами программы одновременно. При интерпретации, наоборот, преобразование и выполнение действий объединены во времени, но для каждого объекта программы.

Если посмотреть на эти различия несколько с другой стороны, то можно заметить, что интерпретатор непосредственно выполняет действия, связанные с определением или преобразованием объектов программы, а компилятор - переводит их на другой (не обязательно машинный язык). Отсюда можно сделать несколько выводов:

· для выполнения программы, написанной на определенном формальном языке после ее компиляции необходим интерпретатор, выполняющий эту программу, но уже записанную на выходном языке компилятора;

· процессор и память любого компьютера (а в широком смысле и вся программная среда, создаваемая операционной системой, является интерпретатором машинного кода);

· в практике построения трансляторов часто встречается случай, когда программа компилируется с входного языка на некоторый промежуточный уровень (внутренний язык), для которого имеется программный интерпретатор. Многие языковые системы программирования, называемые интерпретаторами, на самом деле имеют фазу компиляции во внутренне представление, на котором производится интерпретация.

Выходной язык компилятора может быть машинным языком для компьютера с другой архитектурой, нежели тот, в котором работает компилятор. Такой компилятор называется кросс-компилятором, а сама система программирования кросс-системой программирования. Такие системы используются для разработки программ для архитектур, не имеющих собственных операционных систем или систем программирования (контроллеры, управляющие микропроцессоры).

Таким образом, граница между компиляцией и интерпретацией в трансляторе может перемещаться от входного языка (тогда мы имеем чистый интерпретатор) до машинного кода (тогда речь идет о чистом компиляторе).

Создание слоя программной интерпретации для некоторого промежуточного языка в практике построения трансляторов обычно встречается при попытке обеспечить совместимость для имеющегося многообразия языков программирования, операционных систем, архитектур и т.д. То есть определяется некоторый внутренний промежуточный язык, достаточно простой, чтобы для него можно было написать интерпретатор для всего имеющегося многообразия операционных систем или архитектур. Затем пишется одни (или несколько) компиляторов для одного (или нескольких) входных языков на этот промежуточный уровень. Приведем примеры такой стандартизации:

· для обеспечения совместимости и переносимости трансляторов на компьютеры с различной архитектурой или с различными операционными системами был разработан универсальный внутренний язык (P-код). Для каждой такой архитектуры необходимо реализовать свой интерпретатор P-кода. При этом все разнообразие имеющихся компиляторов с языков высокого уровня на P-код может быть использовано без каких-либо изменений.

· язык программирования Java аналогично был разработан для обеспечения переносимости различных приложений в среде Internet. Исходный текст Java-программы компилируется в байт-код, представляющий собой двоичное представление команд виртуального процессора (виртуальной Java-машины или JVM). Наличие в любом браузере JVM, которая является интерпретатором байт-кода, позволяет передавать по сети и выполнять Java-программу, независимо от архитектуры, операционной системы и т.п..

Одним из существенных свойств «классического» Си является чистый программный код. Что это значит? Во-первых, транслятор представляет собой компилятор, генерирующий программный код целевого процессора. Во-вторых, транслятор «сознательно» не включает в этот код никаких дополнительных команд и обращений к внешним функциям, кроме явно прописанных в программе. То же самое касается и обрабатываемых данных: они имеют прямое представление в памяти без всяких дополнений или изменений. Все это гарантирует программе следующие свойства:

· программист контролирует эффективность полученного программного кода;

· программист контролирует размерности и размещение данных в памяти;

· программный код может выполняться без поддержки какой-либо операционной среды (исполнительной системы языка, библиотек, операционной системы), т.е. на «голой» (standalone) машине.

Именно поэтому на классическом Си могут быть написаны такие компоненты, как программы для встроенных процессоров, ядро и драйверы операционных систем, т.е. то, что традиционно пишется на машинном языке (языке Ассемблера). Поэтому «классический» Си еще называют машинно-независимым Ассемблером.

Что же касается Си++, то там указанные принципы частично нарушаются, хотя он тоже является «чистым» компилятором, но не обеспечивает чистоту программного кода и данных.

Фазы трансляции и выполнения программы
Технология подготовки программ для языков компилирующего типа (к каковым относится Си/Си++) сформировалась в начале 60-х годов и с тех пор не претерпела существенных изменений. Заложенные тогда принципы оказывают влияние на способы использования стандартных библиотечных функций и разработки больших проектов.

Подготовка программы начинается с редактирования файла, содержащего текст этой программы, который имеет стандартное расширение для данного языка. Затем выполняется его трансляция (компиляция), которая включает в себя несколько фаз: препроцессор, лексический, синтаксический, семантический анализ, генерация кода и его оптимизация. В результате трансляции получается объектный модуль - некий «полуфабрикат» готовой программы, который потом участвует в ее сборке. Файл объектного модуля имеет стандартное расширение obj. Компоновка (сборка) программы заключается в объединении одного или нескольких объектных модулей программы и объектных модулей, взятых из библиотечных файлов, содержащих стандартные функции и другие полезные вещи. В результате получается исполняемая программа в виде отдельного файла (загрузочный модуль, программный файл) со стандартным расширением - exe, который затем загружается в память и выполняется.

При модульном проектировании весьма важна разница между определением и объявлением объектов программы (переменных, функций, методов, классов). Определение переменной или функции – это фрагмент программы, в котором полностью задано содержание объекта, и по которому происходит его трансляция во внутреннее представление. Объявление только упоминает объект языка и перечисляет его свойства, если он недоступен в данной точке программы. С учетом раздельного размещения определений и объявлений в проекте модульной Си-программы присутствуют три вида файлов (модулей):

· файлы исходного текста (с расширением - cpp), содержащие определения переменных, функций, методов;

· заголовочные файлы (с расширением - h), содержащие объявления для соответствующих файлов исходного текста;

· объектные модули (с расширением – obj), полученные в результате независимой трансляции файлов исходного текста.

Назначение заголовочных файлов заключается в том, что содержащиеся в них объявления позволяют сформировать правильный программный код для обращения к объекту языка, который определен в другом модуле (следовательно, его внутреннее представление находится в другом объектном модуле). Для обращения к такому внешнему объекту необходимо подключить соответствующий заголовочный файл с его объявлением директивой include. То же самое касается данных и функций, содержащихся в библиотеках и библиотечных классах.

рис. 17.1. Модульное проектирование на «классическом» Си

Препроцессор
Собственно говоря, препроцессор не имеет никакого отношения к языку. Это предварительная фаза трансляции, которая выполняет обработку текста программы, не вдаваясь глубоко в ее содержание. Он производит замену одних частей текста на другие, при этом сама программа так и остается в исходном виде. В языке Си директивы препроцессора оформлены отдельными строками программы, которые начинаются с символа "#". Здесь мы рассмотрим наиболее простые и популярные.

#define идентификатор строка_текста

Директива обеспечивает замену встречающегося в тексте программы идентификатора на соответствующую строку текста. Наиболее часто она применяется для символического обозначения константы, которая встречается многократно в различных частях программы. Например, размерность массива:

```c
#define SIZE 100

int A[SIZE];

for (i=0; i<SIZE; i++) {...}
```

В данном примере вместо имени SIZE в текст программы будет подставлена строка, содержащая константу 100. Теперь, если нас не устраивает размерность массива, нам достаточно увеличить это значение в директиве define и повторно оттранслировать программу.

#define идентификатор(параметры) строка*с*параметрами

Директива отдаленно напоминает определение функции с формальными параметрами, где вместо тела функции используется строка текста. Если препроцессор находит в тексте программы указанный идентификатор со списком фактических параметров в скобках, то он подставляет вместо него соответствующую строку из директивы define с заменой в строке формальных параметров на фактические. Основное отличие от функции: если функция реализует подобные действия (подстановка параметров, вызов) во время работы программы, то препроцессор - еще до трансляции. Кроме этого, директива define позволяет оформить в таком виде любую часть программы, независимо от того, законченная это конструкция языка или ее фрагмент. В следующем примере стандартный заголовок цикла for представлен в виде директивы define с параметрами:

```c
#define FOR(i,n) for(i=0; i<n; i++)

FOR(k,20) A[k]=0; // for(k=0; k<20; k++) A[k]=0;

FOR(j,m+2) {...} // for(j=0; j<m+2; j++) {...}
```

В таком варианте директива define представляет собой макроопределение, а замена в тексте программы идентификатора с параметрами на строку -макроподстановку.

```c
#include <имя_файла>

#include "имя_файла"
```

В текст программы вместо указанной директивы включается текст файла, находящегося в системном или, соответственно, в текущем (явно указанном) каталоге. Наиболее часто в программу включаются тексты заголовочных файлов, содержащие необходимую информацию транслятору о внешних функциях, находящихся в других объектных модулях и библиотеках. Например,

```c
#include <stdio.h>
```

включает в программу текст заголовочного файла, содержащего объявления внешних функций из библиотеки стандартного ввода-вывода.

Еще один полезное средство препроцессора – условная трансляция. Препроцессор способен устанавливать и проверять наличие определения (define) и значения как собственных переменных, так и переменных, содержащих параметры текущего окружения и характеристики транслятора. Например, можно исключить повторное включение кода директивой include, если включаемый текст обрамить такой конструкцией:

```c
#ifndef AA // Код включается только при неопределенной переменной AA

#define AA 0 // Определить переменную препроцессора

… // Включаемый код

#endif
```

Аналогичные средства в других языках программирования носят название макропроцессор, макросредства.

Трансляция и ее фазы
Самое главное в процессе трансляции состоит в том, что он не является линейным, то есть последовательным преобразованием фрагмента программы одного языка на другой. На процесс трансляции одного фрагмента обязательно оказывают влияние другие фрагменты программы. Потому в самом общем виде трансляция заключается в анализе текста программы и построения ее внутреннего представления (внутренней модели), из которой происходит синтез текста эквивалентной программы, но уже на другом языке.

Что касается анализа, то он происходит в три этапа, которые соответствуют трем основным составляющим любого языка программирования.

Лексика языка программирования - это правила «правописания слов» программы, таких как идентификаторы, константы, служебные слова, комментарии. Лексический анализ разбивает текст программы на указанные элементы. Особенность любой лексики -ее элементы представляют собой регулярные линейные последовательности символов. Например, Идентификатор - это произвольная последовательность букв, цифр и символа "_", начинающаяся с буквы или "_".

Синтаксис языка программирования - это правила составления предложений языка из отдельных слов. Такими предложениями являются операции, операторы, определения функций и переменных. Особенностью синтаксиса является принцип вложенности (рекурсивность) правил построения предложений. Это значит, что элемент синтаксиса языка в своем определении прямо или косвенно в одной из его частей содержит сам себя. Например, в определении оператора цикла телом цикла является оператор, частным случаем которого является все тот же оператор цикла.

Семантика языка программирования - это смысл, который закладывается в каждую конструкцию языка. Семантический анализ - это проверка смысловой правильности конструкции. Например, если мы в выражении используем переменную, то она должна быть определена ранее по тексту программы, а из этого определения может быть получен ее тип. Исходя из типа переменной, можно говорит о допустимости операции с данной переменной.

Фаза синтеза зависит от способа трансляции. В компиляторах он состоит в генерации кода, в интерпретаторах – в непосредственном исполнении (интерпретации) полученного внутреннего представления.

Генерация кода - это преобразование элементарных действий, полученных в результате лексического, синтаксического и семантического анализа программы, в некоторое внутреннее представление. Это могут быть коды команд, адреса и содержимое памяти данных, либо текст программы на языке Ассемблера, либо стандартизованный промежуточный код (например, P-код). В процессе генерации кода производится и его оптимизация.

Модульное программирование, компоновка
При независимой трансляции модулей (файлов исходного текста) в результате трансляции получается объектный модуль - некоторый «полуфабрикат», содержащий оттранслированную часть программы во внутреннем представлении, а также информацию о некоторых элементах программы в исходном (символьном) виде:

· программный код, использующий в своей работе только объекты языка (типы данных, переменные, функции), определенные в текущем модуле, полностью переводится во внутреннее (двоичное) представление;

· если объект языка допускает внешний доступ из других модулей, то в объектом модуле создается точка входа, содержащая его имя и внутренний адрес в пространстве объектного модуля;

· при трансляции обращения к внешнему объекту языка объявление, полученное из заголовочного файла позволяет сформировать программный код для обращения к нему. Но все равно неизвестным остается его адрес. Поэтому вместо адреса транслятор оставляет внешнюю ссылку, содержащую исходное (символическое) имя объекта.

Библиотека объектных модулей - это файл (библиотечный файл), содержащий набор объектных модулей и собственный внутренний каталог. Объектные модули библиотеки извлекаются из нее целиком при наличии в них требуемых внешних функций и переменных и используются в процессе компоновки программы.

Компоновка (редактирование связей) - это процесс сборки программы из объектных модулей и библиотек, который включает в себя:

· объединение адресных пространств отдельных модулей (и их содержимого – внутреннего представления программы) в единое адресное пространство программного файла (компоновка);

· «соединение» внешних ссылок и соответствующих им точек входа (редактирование связей);

· при отсутствии необходимых точек входа для внешних ссылок их поиск производится в указанных библиотечных файлах. Если точка входа найдена в библиотеке объектных модулей, то весь объектный модуль, содержащий эту точку, компонуется в программу и для него повторяется описанный выше процесс.

В заключение отметим, что источником объектного модуля может быть не только Си-программа, но и программа, написанная на любом другом языке программирования, например, на Ассемблере. Но в этом случае необходимы дополнительные соглашения по поводу «стыковки» вызовов функций и обращений к данным в различных языках.

Понятие связывания. Статическое и динамическое связывание
Трансляция и последующие действия по подготовке программы к выполнению представляют собой процесс преобразования программы, записанной на некотором формальном языке, в другую формальную систему - архитектуру компьютера, в которой она может быть выполнена (интерпретирована). Для понимания этого процесса, а также отличий, имеющихся в различных языках программирования, вводится понятие связывания, а также времени связывания.

Связывание - процесс установления соответствия между объектами и их свойствами в программе на формальном языке (операции, операторы, данные) и элементами архитектуры компьютера (команды, адреса).

Временем связывания называется соответственно фаза подготовки программы к выполнению (трансляция, компоновка, загрузка), на которой производится это действие. Заметим, что различные характеристики одного и того же объекта (например, переменной) могут связываться с различными элементами архитектуры в разное время, то есть процесс связывания не является одномоментным. Для начала перечислим возможные времена связывания:

· при определении языка;

· при реализации компилятора;

· во время трансляции;

· при компоновке (связывании);

· во время загрузки программы;

· во время выполнения программы, в том числе:

· при входе в модуль (процедуру, функцию);

· в произвольной точке выполнения программы.

В качестве примера рассмотрим простейший фрагмент программы, для которого перечислим более-менее полный перечень времен связывания его различных свойств с элементами архитектуры компьютера:

```c
int a,b; … a+b …
```

1.             Тип переменных int - как способ определения целой переменной в машинном слове стандартной длины (представление целого со знаком, дополнительный код), связывается с аналогичной формой представления данных в компьютере при определении языка. Язык Си характерен тем, что базовые типы данных в нем полностью совпадают с соответствующими формами представления данных в компьютере.

2.             Конкретная размерность переменной int определяется при реализации соответствующего компилятора.

3.             Имя a может быть определено в конструкции вида #define a 0x11FF. В этом случае имя (псевдо-переменная) связывается со своим значением на первой фазе трансляции - в препроцессоре.

4.             Если переменная определяется обычным способом в виде int a; то связывание переменной с соответствующим ей типом происходит во время трансляции (на фазе семантического анализа).

5.             Если переменная определяется как внешняя (глобальная, вне тела функции), то смысл ее трансляции заключается в распределении под нее памяти в сегменте данных программы, который создается для текущего модуля (файла). Но при этом сама распределенной памяти к конкретной оперативной памяти осуществляется в несколько этапов:

· при трансляции переменная привязывается к некоторому относительному адресу в сегменте данных объектного модуля (то есть ее размещение фиксируется только относительно начала модуля)

· при компоновке (связывании) сегменты данных и команд различных объектных модулей объединяются в общий программный файл , представляющий собой образ памяти программы. В нем переменная получает уже относительный адрес от начала всей программы.

· при загрузке программы в некоторую область памяти (например, в DOS или в режиме эмуляции DOS в Windows) она может размещаться не с самого начала этой области. В этом случае осуществляется привязка адресов переменных, заданных в относительных адресах от начала программного модуля к адресам памяти с учетом перемещения программного модуля (так называемый перемещающий загрузчик, которая имеет место для exe-файлов в DOS).

· если программа работает не в физической, а в виртуальной памяти, то процесс загрузки может быть несколько иным. Программный модуль условно считается загруженным в некоторое виртуальное адресное пространство (с перемещением или без него как всей программы, так и отдельных ее сегментов). Реальная загрузка программы в память осуществляется уже в процессе работы программы по частям (сегментам, страницам), причем установление соответствия (или связывание) виртуальных и физических адресов осуществляется динамически операционной системой с использованием соответствующих аппаратных средств.

6.             Если переменная определяется как автоматическая (локальная внутри тела функции или блока), то она размещается  в стеке программы:

· во время трансляции определяется ее размерность и генерируются команды, которые резервируют под нее память в стеке в момент входа в тело функции (блок). То есть в процессе трансляции переменная связывается только с относительным адресом в стеке программы;

· связывание локальным переменной с ее адресом в сегменте стека осуществляется при выполнении в момент входа в тело функции (блок). Благодаря такому способу связывания в рекурсивной функции существует столько «экземпляров» локальных переменных, сколько раз функция вызывает сама себя.

7.             Тип операции “+” в конкретном выражении a+b определяется при трансляции в зависимости от типов операндов. В данном случае генерируется операция целого сложения.

8.             С точки зрения времени связывания понятие инициализация внешних переменных можно определить как связывание переменных с их значениями в процессе трансляции программы (int a=10;)  С этой точки зрения обычное присваивание можно рассматривать как связывание переменной с ее значением во время выполнения программы.

С понятием связывания близко соседствуют термины статический и динамический. Статическим называется элемент языка, полностью определяемый при трансляции (и компоновке). Соответственно, динамический элемент или его свойства определяются при работе программы. Аналогичным образом понимаются термины статическое и динамическое связывание.

В заключение отметим основные свойства Си с точки зрения понятий «связывание, статический, динамический»:

· язык Си является компилируемым языком с большой долей статического связывания. Даже там, где возможно легко реализовать введение динамических компонент (например, создание локальных массивов изменяемой размерности), это исключается ради поддержания единообразия;

· почти все случаи динамического связывания реализуются явно и требуют программной (технологической) поддержки программистом.

Именно поэтому примеры динамического связывания можно «перечесть по пальцам»:

· динамические переменные и массивы (5.6);

· динамическое связывание функций при помощи указателей на функции (9.3);

· виртуальные функции в Си++ (12.4).
